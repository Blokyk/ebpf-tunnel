package main

//go:generate sh -c "rm -f *_bpfel.go *_bpfeb.go"
//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -target amd64 -type Config rerouter rerouter.ebpf.c -- -g -I/usr/include/i386-linux-gnu -I/usr/i686-linux-gnu/include

import (
	"fmt"
	"log"
	"os"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/rlimit"
)

const (
	CGROUP_PATH     = "/sys/fs/cgroup" // Root cgroup path
	TUNNEL_PORT     = 18000            // Port where the tunnel (in go or c) listens
	REAL_PROXY_PORT = 8080             // Port where the real proxy (cntlm) listens
)

type rerouterLinks struct {
	Connect4Link  link.Link
	SockOpsLink   link.Link
	SockOptLink   link.Link
	PostBind4Link link.Link
	CloneProbe    link.Link
	Clone3Probe   link.Link
}

func (links *rerouterLinks) Close() {
	links.Connect4Link.Close()
	links.SockOpsLink.Close()
	links.SockOptLink.Close()
	links.PostBind4Link.Close()
	links.CloneProbe.Close()
	links.Clone3Probe.Close()
}

// Attach eBPF programs to the root cgroup and the right kprobes
func attachProgs(objs rerouterObjects) (rerouterLinks, error) {
	connect4Link, err := link.AttachCgroup(link.CgroupOptions{
		Path:    CGROUP_PATH,
		Attach:  ebpf.AttachCGroupInet4Connect,
		Program: objs.CgConnect4,
	})
	if err != nil {
		return rerouterLinks{}, fmt.Errorf("(CgPostBind4 program) %v", err)
	}

	sockopsLink, err := link.AttachCgroup(link.CgroupOptions{
		Path:    CGROUP_PATH,
		Attach:  ebpf.AttachCGroupSockOps,
		Program: objs.CgSockOps,
	})
	if err != nil {
		return rerouterLinks{}, fmt.Errorf("(CgPostBind4 program) %v", err)
	}

	sockoptLink, err := link.AttachCgroup(link.CgroupOptions{
		Path:    CGROUP_PATH,
		Attach:  ebpf.AttachCGroupGetsockopt,
		Program: objs.CgSockOpt,
	})
	if err != nil {
		return rerouterLinks{}, fmt.Errorf("(CgPostBind4 program) %v", err)
	}

	postBind4Link, err := link.AttachCgroup(link.CgroupOptions{
		Path:    CGROUP_PATH,
		Attach:  ebpf.AttachCGroupInet4PostBind,
		Program: objs.CgPostBind4,
	})
	if err != nil {
		return rerouterLinks{}, fmt.Errorf("(CgPostBind4 program) %v", err)
	}

	cloneProbeLink, err := link.Kretprobe("sys_clone", objs.ProbeClone, nil)
	if err != nil {
		return rerouterLinks{}, fmt.Errorf("(clone probe) %v", err)
	}

	clone3ProbeLink, err := link.Kretprobe("sys_clone3", objs.ProbeClone3, nil)
	if err != nil {
		return rerouterLinks{}, fmt.Errorf("(clone3 probe) %v", err)
	}

	return rerouterLinks{
		connect4Link,
		sockopsLink,
		sockoptLink,
		postBind4Link,
		cloneProbeLink,
		clone3ProbeLink,
	}, nil
}

func main() {
	// Remove resource limits for kernels <5.11.
	if err := rlimit.RemoveMemlock(); err != nil {
		log.Print("Removing memlock:", err)
	}

	// Load the compiled eBPF ELF and load it into the kernel
	// NOTE: we could also pin the eBPF program
	var objs rerouterObjects
	if err := loadRerouterObjects(&objs, nil); err != nil {
		log.Fatalf("Error loading eBPF program: %v", err)
	}
	defer objs.Close()

	links, err := attachProgs(objs)
	if err != nil {
		log.Fatalf("Couldn't attach some programs: %v", err)
	}
	defer links.Close()

	// Update the rerouter map with the proxy server configuration, because we need to know the proxy server PID in order
	// to filter out eBPF events generated by the proxy server itself so it would not proxy its own packets in a loop.
	var key uint32 = 0
	config := rerouterConfig{
		ProxyPort:     TUNNEL_PORT,
		ProxyPid:      uint64(os.Getpid()),
		RealProxyPort: REAL_PROXY_PORT,
		// RealProxyPid:  realProxyPid,
		WhitelistCount: 0,
	}
	err = objs.rerouterMaps.MapConfig.Update(&key, &config, ebpf.UpdateAny)
	if err != nil {
		log.Fatalf("Failed to update proxyMaps map: %v", err)
	}

	err = whitelistPort(REAL_PROXY_PORT, objs.rerouterMaps)
	if err == nil {
		log.Print("Added proxy to rerouter whitelist successfully")
	} else {
		log.Print(err)
	}

	whitelistPort(TUNNEL_PORT, objs.rerouterMaps)
	if err == nil {
		log.Print("Added tunnel to rerouter whitelist successfully")
	} else {
		log.Print(err)
	}

	log.Printf("eBPF rerouter setup finished, redirecting all requests to %d", TUNNEL_PORT)
	fmt.Print("Press Enter to exit")
	fmt.Scanln()
}
